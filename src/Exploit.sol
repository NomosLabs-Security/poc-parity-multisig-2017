// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Parity Multisig — Vulnerable WalletLibrary Simulation
/// @notice Educational reproduction of the Parity WalletLibrary self-destruct bug.
///         Uses Solidity 0.8+ but simulates the original 0.4.x behavior.

/// @dev Simulates the shared WalletLibrary that all Parity wallets delegatecall to.
///      The critical flaw: initWallet() was callable by anyone on the library contract itself.
contract WalletLibrary {
    // Wallet state (in library's own storage when called directly)
    address[] public owners;
    uint256 public required;
    uint256 public numOwners;
    bool public killed;

    // Simulate selfdestruct by setting a flag (actual selfdestruct behavior changed in Dencun)
    event SelfDestructed(address indexed beneficiary);

    /// @notice Initialize the wallet — VULNERABLE: no access control on the library itself
    function initWallet(address[] memory _owners, uint256 _required) public {
        // Original check: only callable if not yet initialized
        require(numOwners == 0, "already initialized");
        require(_owners.length > 0, "need owners");
        require(_required > 0 && _required <= _owners.length, "invalid required");

        for (uint256 i = 0; i < _owners.length; i++) {
            owners.push(_owners[i]);
        }
        numOwners = _owners.length;
        required = _required;
    }

    modifier onlyOwner() {
        bool isOwner = false;
        for (uint256 i = 0; i < owners.length; i++) {
            if (owners[i] == msg.sender) {
                isOwner = true;
                break;
            }
        }
        require(isOwner, "not owner");
        _;
    }

    /// @notice Kill the library — VULNERABLE: selfdestruct accessible after initWallet()
    function kill(address payable _to) public onlyOwner {
        killed = true;
        emit SelfDestructed(_to);
        // In original: selfdestruct(_to);
        // We simulate with a flag since selfdestruct is restricted post-Dencun
    }

    /// @notice Example wallet function — will fail after kill
    function execute(address _to, uint256 _value, bytes memory _data) public onlyOwner returns (bool) {
        require(!killed, "library is dead");
        (bool success,) = _to.call{value: _value}(_data);
        return success;
    }

    receive() external payable {}
}

/// @dev Proxy wallet that delegatecalls to WalletLibrary
contract WalletProxy {
    address public libraryAddress;

    // These mirror WalletLibrary storage layout
    address[] public owners;
    uint256 public required;
    uint256 public numOwners;

    constructor(address _library) {
        libraryAddress = _library;
    }

    /// @notice Initialize this proxy's own storage via delegatecall
    function initWallet(address[] memory _owners, uint256 _required) public {
        (bool success,) = libraryAddress.delegatecall(
            abi.encodeWithSignature("initWallet(address[],uint256)", _owners, _required)
        );
        require(success, "init failed");
    }

    /// @notice Forward all calls to library via delegatecall
    fallback() external payable {
        address lib = libraryAddress;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), lib, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    receive() external payable {}
}
